{{!-- Quality Coach Researcher - Floating Chat Widget --}}
{{!-- Server-side beta access is handled by /api/v1/access/check.
    No API keys or email lists should be injected into the browser. --}}

{{#if @member}}
    <div id="qc-access-message" class="qc-access-message" role="status"></div>
    
    {{!-- Floating Chat Widget --}}
    <div id="quality-coach-widget" class="qc-widget qc-widget--initializing">

        {{!-- Chat Button (initially visible) --}}
        <button 
            id="qc-chat-button" 
            class="qc-chat-button is-loading" 
            type="button"
            aria-label="Open Quality Coach Researcher"
            aria-haspopup="dialog"
            aria-controls="qc-chat-window"
            aria-expanded="false"
            aria-disabled="true"
            title="Checking access">
            <span class="qc-chat-button-icon qc-chat-button-icon--chat" aria-hidden="true">
                ðŸ“š
            </span>
            <span class="qc-chat-button-icon qc-chat-button-icon--close" aria-hidden="true">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </span>
        </button>

        {{!-- Chat Window (hidden by default) --}}
        <div id="qc-chat-window" class="qc-chat-window" role="dialog" aria-modal="true" aria-label="Quality Coach Researcher">
            <div class="qc-window-handle" aria-hidden="true">
                <span></span>
            </div>
            {{!-- Header --}}
            <div class="qc-window-header">
                <div class="qc-header-content">
                    <div class="qc-header-brand">
                        <span class="qc-header-icon">ðŸ“š</span>
                        <h3 class="qc-header-title">Quality Coach <span class="qc-header-subtitle">Researcher</span></h3>
                    </div>
                    {{!-- Persona Badge --}}
                    <div class="qc-persona-badge" id="qc-persona-badge" style="display: none;">
                        <button class="qc-persona-button" id="qc-persona-button" type="button" aria-haspopup="true" aria-expanded="false">
                            <span id="qc-persona-label">Quality Coach</span>
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </button>
                        <div class="qc-persona-dropdown" id="qc-persona-dropdown" style="display: none;">
                            <div class="qc-persona-dropdown-header">
                                <span>I am a:</span>
                                <button class="qc-persona-close" id="qc-persona-close" type="button" aria-label="Close">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="18" y1="6" x2="6" y2="18"></line>
                                        <line x1="6" y1="6" x2="18" y2="18"></line>
                                    </svg>
                                </button>
                            </div>
                            <button class="qc-persona-option" data-persona="QUALITY_COACH">Quality Coach</button>
                            <button class="qc-persona-option" data-persona="ENGINEERING_MANAGER">Engineering Manager</button>
                            <button class="qc-persona-option" data-persona="DELIVERY_LEAD">Delivery Lead</button>
                            <button class="qc-persona-option" data-persona="CEO_EXECUTIVE">CEO/Executive</button>
                            <button class="qc-persona-option" data-persona="SOFTWARE_ENGINEER">Software Engineer</button>
                            <button class="qc-persona-option" data-persona="TEST_LEAD">Test Lead</button>
                            <button class="qc-persona-option" data-persona="OTHER">Other</button>
                        </div>
                    </div>
                </div>
                <button id="qc-close-button" class="qc-close-button" aria-label="Close chat">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>

            {{!-- Messages Area --}}
            <div id="qc-messages" class="qc-messages">
                <div class="qc-welcome-message">
                    <p><span class="qc-welcome-icon">ðŸ“š</span> <strong>Welcome!</strong> I'll help you explore Anne-Marie's Quality Coach's Handbook.</p>
                    <p class="qc-welcome-hint">Ask me about coaching techniques, quality practices, or what workshop to run.</p>
                </div>
            </div>

            {{!-- Typing Indicator --}}
            <div id="qc-typing" class="qc-typing" style="display: none;">
                <div class="qc-typing-dot"></div>
                <div class="qc-typing-dot"></div>
                <div class="qc-typing-dot"></div>
            </div>

            {{!-- Input Area --}}
            <div class="qc-input-area">
                <textarea 
                    id="qc-input" 
                    class="qc-input" 
                    placeholder="Ask a question..."
                    rows="1"
                    maxlength="500"></textarea>
                <button id="qc-send" class="qc-send-button" aria-label="Send message">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                </button>
            </div>

            {{!-- Footer --}}
            <div class="qc-window-footer">
                <span class="qc-footer-disclaimer">Grounded in the Handbook, supplemented by coaching expertise</span>
            </div>
        </div>

        <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Automatically switch between local and production backend
            const API_BASE = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
                ? 'http://localhost:8000'
                : 'https://qchb-chat.fly.dev';
            
            const ACCESS_URL = `${API_BASE}/api/v1/access/check`;
            const CHAT_URL = `${API_BASE}/api/v1/chat`;
            const memberEmail = '{{@member.email}}';
            const isPaidMember = {{#if @member.paid}}true{{else}}false{{/if}};
            const DEFAULT_PLACEHOLDER = 'Ask a question...';
            const FEEDBACK_PREFIX = 'feedback:';
            const ACCESS_CACHE_PREFIX = 'qc_access_cache:';
            const ACCESS_CACHE_MIN_VALID_MS = 30 * 1000;
            const ACCESS_REFRESH_BUFFER_MS = 5 * 60 * 1000;
            const ACCESS_LAG_MESSAGE_MS = 4000;

            const accessMessage = document.getElementById('qc-access-message');
            const widgetContainer = document.getElementById('quality-coach-widget');
            const chatButton = document.getElementById('qc-chat-button');
            const chatWindow = document.getElementById('qc-chat-window');
            const closeButton = document.getElementById('qc-close-button');
            const messages = document.getElementById('qc-messages');
            const feedbackTemplate = document.getElementById('qc-feedback-panel-template');
            const input = document.getElementById('qc-input');
            const sendButton = document.getElementById('qc-send');
            const typingIndicator = document.getElementById('qc-typing');
            const PORTAL_SELECTORS = [
                '.gh-portal-triggerbtn',
                '.gh-portal-triggerbtn-root',
                '#ghost-portal-root',
                'iframe[src*="ghost" i][title*="portal" i]'
            ];
            const PORTAL_OFFSET_CLASS = 'qc-offset-for-portal';
            const PORTAL_CHECK_INTERVAL_MS = 2000;
            const PORTAL_FALLBACK_TIMEOUT_MS = 5000;

            if (!chatButton || !chatWindow || !input || !sendButton || !closeButton) {
                return;
            }

            if (typeof window !== 'undefined') {
                window.QUALITY_COACH_SESSION = {
                    status: 'pending',
                    email: memberEmail
                };
            }

            // Initialize Quality Coach Client
            // Ensure QualityCoachClient is available
            if (typeof QualityCoachClient === 'undefined') {
                console.error('QualityCoachClient not loaded');
                return;
            }

            const client = new QualityCoachClient({
                apiBase: API_BASE,
                storageKey: 'qc_thread_id'
            });
            
            // Initialize thread ID immediately
            const clientThreadId = client.init();

            let accessToken = null;
            let hasAccess = false;
            let isOpen = false;
            let isLocked = false;
            let conversationHistory = [];
            
            let portalObserver = null;
            let portalInterval = null;
            let portalFallbackTimer = null;
            let lastAssistantMessage = null;
            let accessRefreshTimer = null;
            let accessLagTimer = null;
            
            // Persona state
            let currentPersona = null;
            let currentPersonaConfidence = 0;
            let detectedPersonaMessage = ''; // Track message that triggered detection
            let hasShownPersonaConfirmation = false; // Only show once per session
            const personaNames = {
                'QUALITY_COACH': 'Quality Coach',
                'ENGINEERING_MANAGER': 'Engineering Manager',
                'DELIVERY_LEAD': 'Delivery Lead',
                'CEO_EXECUTIVE': 'CEO/Executive',
                'SOFTWARE_ENGINEER': 'Software Engineer',
                'TEST_LEAD': 'Test Lead',
                'OTHER': 'Other'
            };
            
            // Persona UI elements
            const personaBadge = document.getElementById('qc-persona-badge');
            const personaButton = document.getElementById('qc-persona-button');
            const personaLabel = document.getElementById('qc-persona-label');
            const personaDropdown = document.getElementById('qc-persona-dropdown');

            chatButton.classList.add('is-loading');

            initializeAccess();
            monitorPortalTrigger();
            restorePersonaBadge();
            if (input) {
                input.placeholder = DEFAULT_PLACEHOLDER;
            }
            
            // Restore persona badge for returning users
            function restorePersonaBadge() {
                const savedPersona = localStorage.getItem('qc_persona_choice');
                const hasConfirmed = localStorage.getItem('qc_persona_confirmed');
                
                if (hasConfirmed && savedPersona && personaBadge && personaLabel) {
                    currentPersona = savedPersona;
                    personaLabel.textContent = personaNames[savedPersona] || savedPersona;
                    personaBadge.style.display = 'flex';
                }
            }

            function showStatus(message, variant = 'info') {
                if (!accessMessage) return;
                if (!message) {
                    accessMessage.textContent = '';
                    accessMessage.style.display = 'none';
                    accessMessage.className = 'qc-access-message';
                    return;
                }
                accessMessage.textContent = message;
                accessMessage.style.display = 'flex';
                accessMessage.className = `qc-access-message qc-${variant}`;
            }

            function startAccessLagTimer() {
                if (accessLagTimer) {
                    clearTimeout(accessLagTimer);
                }
                accessLagTimer = setTimeout(() => {
                    showStatus('Still checking accessâ€¦', 'info');
                }, ACCESS_LAG_MESSAGE_MS);
            }

            function stopAccessLagTimer() {
                if (accessLagTimer) {
                    clearTimeout(accessLagTimer);
                    accessLagTimer = null;
                }
            }

            function attemptRestoreCachedAccess() {
                const cached = loadAccessCache();
                if (!cached) {
                    return false;
                }
                if (!canUseCachedAccess(cached)) {
                    clearAccessCache();
                    return false;
                }
                applyAccessSuccess({
                    access_token: cached.access_token,
                    access_expires_at: cached.access_expires_at,
                    access_granted_via: cached.access_granted_via,
                    is_beta_tester: cached.is_beta_tester,
                    is_paid_member: cached.is_paid_member
                }, {
                    source: 'cache',
                    skipCache: true
                });
                return true;
            }

            function applyAccessSuccess(data, { source = 'network', skipCache = false } = {}) {
                if (!data || !data.access_token) {
                    return;
                }
                accessToken = data.access_token;
                // Ensure client has the token
                client.setAccessToken(accessToken);
                
                hasAccess = true;
                isLocked = false;
                if (widgetContainer) {
                    widgetContainer.classList.remove('qc-widget--hidden');
                    widgetContainer.classList.remove('qc-widget--initializing');
                }
                window.QUALITY_COACH_SESSION = {
                    token: accessToken,
                    expires_at: data.access_expires_at,
                    granted_via: data.access_granted_via,
                    email: memberEmail,
                    status: 'ready',
                    source,
                    is_beta_tester: data.is_beta_tester,
                    is_paid_member: data.is_paid_member
                };

                setButtonAccessibility({ disabled: false, loading: false, tooltip: 'Open Quality Coach Researcher' });
                if (!skipCache) {
                    saveAccessCache({
                        access_token: data.access_token,
                        access_expires_at: data.access_expires_at,
                        access_granted_via: data.access_granted_via,
                        is_beta_tester: data.is_beta_tester,
                        is_paid_member: data.is_paid_member
                    });
                }
                scheduleAccessRefresh(data.access_expires_at);
                showStatus('');
                
                // Load history if available
                loadConversationHistory();
            }

            function scheduleAccessRefresh(expiresAt) {
                if (accessRefreshTimer) {
                    clearTimeout(accessRefreshTimer);
                    accessRefreshTimer = null;
                }
                if (!expiresAt) return;
                const expiryTime = Date.parse(expiresAt);
                if (!expiryTime) return;
                const delay = expiryTime - Date.now() - ACCESS_REFRESH_BUFFER_MS;
                if (delay <= 0) {
                    accessRefreshTimer = setTimeout(() => {
                        refreshAccessToken('expired');
                    }, 1000);
                    return;
                }
                accessRefreshTimer = setTimeout(() => {
                    refreshAccessToken('scheduled');
                }, delay);
            }

            async function refreshAccessToken(reason = 'scheduled') {
                try {
                    await performAccessCheck({ silent: true });
                } catch (error) {
                    if (typeof console !== 'undefined' && console.debug) {
                        console.debug('Access refresh failed', reason, error);
                    }
                }
            }

            function getCacheKey() {
                return `${ACCESS_CACHE_PREFIX}${memberEmail || 'anonymous'}`;
            }

            function loadAccessCache() {
                if (typeof sessionStorage === 'undefined') return null;
                try {
                    const raw = sessionStorage.getItem(getCacheKey());
                    if (!raw) return null;
                    return JSON.parse(raw);
                } catch (error) {
                    clearAccessCache();
                    return null;
                }
            }

            function saveAccessCache(payload) {
                if (typeof sessionStorage === 'undefined' || !payload) return;
                const cacheEntry = {
                    ...payload,
                    cached_at: new Date().toISOString(),
                    member_email: memberEmail
                };
                try {
                    sessionStorage.setItem(getCacheKey(), JSON.stringify(cacheEntry));
                } catch (error) {
                    // Ignore quota errors silently
                }
            }

            function clearAccessCache() {
                if (typeof sessionStorage === 'undefined') return;
                sessionStorage.removeItem(getCacheKey());
                if (accessRefreshTimer) {
                    clearTimeout(accessRefreshTimer);
                    accessRefreshTimer = null;
                }
            }

            function canUseCachedAccess(entry) {
                if (!entry || !entry.access_token || !entry.access_expires_at) {
                    return false;
                }
                const expiryTime = Date.parse(entry.access_expires_at);
                if (!expiryTime) {
                    return false;
                }
                if (expiryTime - Date.now() <= ACCESS_CACHE_MIN_VALID_MS) {
                    return false;
                }
                return true;
            }

            function monitorPortalTrigger() {
                if (typeof document === 'undefined') return;

                updatePortalOffset();

                if (typeof MutationObserver !== 'undefined') {
                    if (portalObserver) {
                        portalObserver.disconnect();
                    }
                    portalObserver = new MutationObserver(() => {
                        updatePortalOffset();
                    });
                    portalObserver.observe(document.body, {
                        childList: true,
                        subtree: true
                    });
                }

                if (!portalInterval) {
                    portalInterval = setInterval(() => {
                        updatePortalOffset();
                    }, PORTAL_CHECK_INTERVAL_MS);
                }

                if (!portalFallbackTimer) {
                    portalFallbackTimer = setTimeout(() => {
                        if (document.body && !document.body.classList.contains(PORTAL_OFFSET_CLASS)) {
                            document.body.classList.add(PORTAL_OFFSET_CLASS);
                        }
                    }, PORTAL_FALLBACK_TIMEOUT_MS);
                }
            }

            function updatePortalOffset() {
                if (!document.body) return;
                const portalElement = findPortalElement();
                const hasPortal = Boolean(portalElement);
                document.body.classList.toggle(PORTAL_OFFSET_CLASS, hasPortal);

                if (hasPortal && portalFallbackTimer) {
                    clearTimeout(portalFallbackTimer);
                    portalFallbackTimer = null;
                }

                if (hasPortal && portalInterval) {
                    clearInterval(portalInterval);
                    portalInterval = null;
                }
            }

            function findPortalElement() {
                for (const selector of PORTAL_SELECTORS) {
                    if (!selector) continue;
                    const el = document.querySelector(selector);
                    if (el) {
                        return el;
                    }
                }
                return null;
            }

            async function loadConversationHistory() {
                if (!clientThreadId || !accessToken) return;
                
                // Avoid loading if we already have history in memory (e.g. from previous session in same window)
                if (conversationHistory.length > 0) return;

                try {
                    const messages = await client.getHistory();
                    
                    if (Array.isArray(messages) && messages.length > 0) {
                        // Clear welcome message if we have history
                        const welcomeMsg = document.querySelector('.qc-welcome-message');
                        if (welcomeMsg) welcomeMsg.style.display = 'none';

                        messages.forEach(msg => {
                            addMessage(msg.content, msg.role);
                            conversationHistory.push({ role: msg.role, content: msg.content });
                        });
                    }
                } catch (error) {
                    console.debug('Failed to load conversation history', error);
                }
            }

            async function initializeAccess() {
                const restored = attemptRestoreCachedAccess();
                if (restored) {
                    return;
                }
                await performAccessCheck();
            }

            async function performAccessCheck({ silent = false } = {}) {
                if (!silent) {
                    showStatus('Checking accessâ€¦');
                    startAccessLagTimer();
                }

                try {
                    const data = await client.checkAccess(memberEmail);

                    if (widgetContainer) {
                        widgetContainer.classList.remove('qc-widget--initializing');
                    }

                    if (!data.has_access || !data.access_token) {
                        hasAccess = false;
                        isLocked = true;
                        hideChatWidget();
                        showStatus(data.reason || 'The Researcher is available to beta testers only right now.', 'warning');
                        clearAccessCache();
                        return false;
                    }

                    // Update client with token
                    client.setAccessToken(data.access_token);

                    applyAccessSuccess(data, {
                        source: silent ? 'refresh' : 'network'
                    });
                    return true;
                } catch (error) {
                    hasAccess = false;
                    isLocked = true;
                    if (widgetContainer) {
                        widgetContainer.classList.remove('qc-widget--initializing');
                    }
                    setButtonAccessibility({ disabled: true, loading: false, tooltip: 'Unable to verify beta access. Please refresh and try again.' });
                    if (!silent) {
                        showStatus('Unable to verify beta access. Please refresh and try again.', 'error');
                    }
                    clearAccessCache();
                    return false;
                } finally {
                    if (!silent) {
                        stopAccessLagTimer();
                    }
                }
            }

            function setButtonAccessibility({ disabled, loading, tooltip }) {
                if (!chatButton) return;
                chatButton.classList.toggle('is-loading', Boolean(loading));
                if (typeof disabled !== 'undefined') {
                    if (disabled) {
                        chatButton.setAttribute('aria-disabled', 'true');
                        chatButton.disabled = true;
                    } else {
                        chatButton.removeAttribute('aria-disabled');
                        chatButton.disabled = false;
                    }
                }
                if (tooltip) {
                    chatButton.setAttribute('title', tooltip);
                } else {
                    chatButton.removeAttribute('title');
                }
            }

            function hideChatWidget() {
                if (widgetContainer) {
                    widgetContainer.classList.add('qc-widget--hidden');
                }
                setButtonAccessibility({ disabled: true, loading: false });
            }

            // Toggle chat window
            chatButton.addEventListener('click', function() {
                if (chatButton.getAttribute('aria-disabled') === 'true') {
                    const lockedCopy = isLocked
                        ? 'The Researcher is available to approved members. Reach out to join the beta.'
                        : 'Still checking accessâ€¦';
                    showStatus(lockedCopy, isLocked ? 'warning' : 'info');
                    return;
                }

                if (isOpen) {
                    closeChatWindow();
                } else {
                    openChatWindow();
                }
            });

            closeButton.addEventListener('click', closeChatWindow);

            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape' && isOpen) {
                    closeChatWindow();
                }
            });

            function openChatWindow() {
                if (!hasAccess) {
                    showStatus('The Researcher is available to approved members. Reach out to join the beta.', 'warning');
                    return;
                }
                isOpen = true;
                chatWindow.classList.add('is-visible');
                chatButton.classList.add('is-open');
                chatButton.setAttribute('aria-expanded', 'true');
                chatButton.setAttribute('aria-label', 'Close Quality Coach Researcher');
                input.focus();

                if (typeof gtag !== 'undefined') {
                    gtag('event', 'quality_coach_opened', {
                        'post_slug': '{{slug}}',
                        'post_title': '{{title}}'
                    });
                }
            }

            function closeChatWindow() {
                isOpen = false;
                chatWindow.classList.remove('is-visible');
                chatButton.classList.remove('is-open');
                chatButton.setAttribute('aria-expanded', 'false');
                chatButton.setAttribute('aria-label', 'Open Quality Coach Researcher');
                chatButton.focus();
            }

            // Auto-resize textarea
            input.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 120) + 'px';
            });

            // Send on Enter (Shift+Enter for newline)
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            sendButton.addEventListener('click', sendMessage);
            
            // Persona dropdown toggle (header badge)
            if (personaButton && personaDropdown) {
                personaButton.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const isVisible = personaDropdown.style.display === 'block';
                    personaDropdown.style.display = isVisible ? 'none' : 'block';
                    personaButton.setAttribute('aria-expanded', !isVisible);
                });
                
                // Close button in dropdown
                const personaCloseBtn = document.getElementById('qc-persona-close');
                if (personaCloseBtn) {
                    personaCloseBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        personaDropdown.style.display = 'none';
                        personaButton.setAttribute('aria-expanded', 'false');
                    });
                }
                
                // Close dropdown when clicking outside
                document.addEventListener('click', function(e) {
                    if (!personaButton.contains(e.target) && !personaDropdown.contains(e.target)) {
                        personaDropdown.style.display = 'none';
                        personaButton.setAttribute('aria-expanded', 'false');
                    }
                });
                
                // Handle persona option clicks
                const personaOptions = document.querySelectorAll('.qc-persona-option');
                personaOptions.forEach(option => {
                    option.addEventListener('click', function() {
                        const selectedPersona = this.dataset.persona;
                        correctPersona(selectedPersona, 'user_selected');
                        personaDropdown.style.display = 'none';
                        personaButton.setAttribute('aria-expanded', 'false');
                    });
                });
            }

            function sendMessage(options = {}) {
                if (!hasAccess || !accessToken) {
                    showStatus('Your access token expired. Refresh the page to continue.', 'warning');
                    return;
                }

                const { messageOverride = null, isFeedbackOverride = null, skipUserMessage = false } = options;
                const usingPrimaryInput = messageOverride === null;
                const sourceValue = usingPrimaryInput ? input.value : messageOverride;
                const rawMessage = (sourceValue || '').trim();
                if (!rawMessage) return;

                const hasLegacyFeedbackPrefix = usingPrimaryInput && rawMessage.toLowerCase().startsWith(FEEDBACK_PREFIX);
                const cleanedMessage = hasLegacyFeedbackPrefix
                    ? rawMessage.slice(FEEDBACK_PREFIX.length).trimStart()
                    : rawMessage;
                const isFeedback = typeof isFeedbackOverride === 'boolean'
                    ? isFeedbackOverride
                    : hasLegacyFeedbackPrefix;

                if (isFeedback && !cleanedMessage) {
                    showStatus('Share a short note before sending feedback.', 'warning');
                    return;
                }

                if (isFeedback) {
                    showStatus('Thanks for the feedback â€” it goes straight to Anne-Marie.', 'info');
                }

                const displayMessage = isFeedback ? cleanedMessage : rawMessage;
                if (!isFeedback && !skipUserMessage) {
                    addMessage(displayMessage, 'user', null, null, isFeedback);
                }

                if (usingPrimaryInput) {
                    input.value = '';
                    input.style.height = 'auto';
                }

                if (usingPrimaryInput) {
                    input.disabled = true;
                    sendButton.disabled = true;
                }
                typingIndicator.style.display = 'flex';

                return client.sendMessage(cleanedMessage, conversationHistory, {
                    post_slug: '{{slug}}',
                    post_title: '{{title}}',
                    member_email: memberEmail,
                    is_feedback: isFeedback
                })
                .then(data => {
                    typingIndicator.style.display = 'none';

                    if (data.answer) {
                        if (!isFeedback) {
                            // Check for confirmation need
                            const needsConfirmation = data.persona && 
                                                    !hasShownPersonaConfirmation && 
                                                    !localStorage.getItem('qc_persona_confirmed');

                            if (needsConfirmation) {
                                currentPersona = data.persona;
                                currentPersonaConfidence = data.persona_confidence;
                                detectedPersonaMessage = cleanedMessage;
                                
                                // Update footer badge immediately so user sees what we detected
                                updatePersonaDropdown(data.persona);
                                
                                // Show confirmation instead of answer
                                showPersonaConfirmation(data.persona, data.persona_confidence, {
                                    answer: data.answer,
                                    sources: data.sources,
                                    originalMessage: cleanedMessage
                                });
                                return; // STOP HERE
                            }

                            // Update persona if returned by backend
                            if (data.persona) {
                                currentPersona = data.persona;
                                currentPersonaConfidence = data.persona_confidence;
                                detectedPersonaMessage = cleanedMessage;
                                
                                // Update footer badge (always visible)
                                updatePersonaDropdown(data.persona);
                            }
                            
                            addMessage(data.answer, 'assistant', data.sources);
                            conversationHistory.push({ role: 'user', content: cleanedMessage });
                            conversationHistory.push({ role: 'assistant', content: data.answer });
                        }
                        
                        if (isFeedback && typeof gtag !== 'undefined') {
                            gtag('event', 'quality_coach_feedback_submitted', {
                                'post_slug': '{{slug}}',
                                'post_title': '{{title}}'
                            });
                        }
                    } else {
                        addMessage('Sorry, I encountered an error. Please try again.', 'error', null, null);
                    }
                })
                .catch(error => {
                    typingIndicator.style.display = 'none';
                    
                    if (error.message.includes('401') || error.message.includes('403')) {
                        hasAccess = false;
                        isLocked = true;
                        showStatus('Your access expired. Refresh the page to continue.', 'warning');
                        setButtonAccessibility({ disabled: true, loading: false, tooltip: 'Access expired - refresh to continue.' });
                    } else {
                        addMessage('Sorry, I\'m having trouble connecting. Please try again later.', 'error');
                    }
                })
                .finally(() => {
                    if (usingPrimaryInput) {
                        input.disabled = false;
                        sendButton.disabled = false;
                        input.focus();
                    }
                });
            }

            function formatMessage(content) {
                return content
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/^- (.*?)$/gm, 'â€¢ $1')
                    .replace(/\n/g, '<br>');
            }
            
            function updatePersonaDropdown(persona) {
                if (!persona) return;
                
                // Mark active option in dropdown
                const options = document.querySelectorAll('.qc-persona-option');
                options.forEach(opt => {
                    if (opt.dataset.persona === persona) {
                        opt.classList.add('is-active');
                    } else {
                        opt.classList.remove('is-active');
                    }
                });
                
                // Update header persona label if visible
                if (personaLabel) {
                    const personaNames = {
                        'QUALITY_COACH': 'Quality Coach',
                        'ENGINEERING_MANAGER': 'Engineering Manager',
                        'DELIVERY_LEAD': 'Delivery Lead',
                        'CEO_EXECUTIVE': 'CEO/Executive',
                        'SOFTWARE_ENGINEER': 'Software Engineer',
                        'TEST_LEAD': 'Test Lead'
                    };
                    personaLabel.textContent = personaNames[persona] || persona;
                }
            }
            
            function showPersonaConfirmation(persona, confidence, deferredData = null) {
                // Only show once per session AND only if not previously confirmed
                const hasConfirmed = localStorage.getItem('qc_persona_confirmed');
                
                if (hasShownPersonaConfirmation || hasConfirmed) {
                    // If we have deferred data but confirmation was already shown/confirmed elsewhere,
                    // we should probably just show the answer?
                    if (deferredData && deferredData.answer) {
                         addMessage(deferredData.answer, 'assistant', deferredData.sources);
                         conversationHistory.push({ role: 'user', content: deferredData.originalMessage });
                         conversationHistory.push({ role: 'assistant', content: deferredData.answer });
                    }
                    return;
                }
                
                hasShownPersonaConfirmation = true;
                
                const displayName = personaNames[persona] || persona;
                const confirmDiv = document.createElement('div');
                confirmDiv.className = 'qc-persona-confirmation';
                confirmDiv.setAttribute('tabindex', '-1');
                confirmDiv.innerHTML = `
                    <div class="qc-persona-confirmation-content">
                        <div class="qc-persona-confirmation-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                                <circle cx="12" cy="7" r="4"></circle>
                            </svg>
                        </div>
                        <div class="qc-persona-confirmation-text">
                            <strong>I'm responding as if you're a ${displayName}.</strong>
                            <span>Is that right?</span>
                        </div>
                        <div class="qc-persona-confirmation-actions">
                            <button class="qc-persona-confirm-yes" data-action="confirm">Yes, that's right</button>
                            <button class="qc-persona-confirm-change" data-action="change">Actually, I'm a...</button>
                        </div>
                    </div>
                `;
                
                messages.appendChild(confirmDiv);
                messages.scrollTop = messages.scrollHeight;
                confirmDiv.focus();
                
                // Handle confirmation actions
                confirmDiv.querySelector('[data-action="confirm"]').addEventListener('click', function() {
                    confirmPersona(persona);
                    confirmDiv.classList.add('qc-fade-out');
                    setTimeout(() => confirmDiv.remove(), 300);

                    // Show the deferred answer
                    if (deferredData && deferredData.answer) {
                         addMessage(deferredData.answer, 'assistant', deferredData.sources);
                         conversationHistory.push({ role: 'user', content: deferredData.originalMessage });
                         conversationHistory.push({ role: 'assistant', content: deferredData.answer });
                    }
                });
                
                confirmDiv.querySelector('[data-action="change"]').addEventListener('click', function() {
                    showPersonaSelector(confirmDiv, persona, deferredData);
                });
            }
            
            function showPersonaSelector(confirmDiv, originalPersona, deferredData = null) {
                confirmDiv.innerHTML = `
                    <div class="qc-persona-confirmation-content">
                        <div class="qc-persona-confirmation-text">
                            <strong>What's your role?</strong>
                        </div>
                        <div class="qc-persona-selector">
                            <button class="qc-persona-select-option" data-persona="QUALITY_COACH">
                                <span class="qc-persona-icon">ðŸŽ¯</span>
                                <span>Quality Coach</span>
                            </button>
                            <button class="qc-persona-select-option" data-persona="ENGINEERING_MANAGER">
                                <span class="qc-persona-icon">ðŸ‘”</span>
                                <span>Engineering Manager</span>
                            </button>
                            <button class="qc-persona-select-option" data-persona="DELIVERY_LEAD">
                                <span class="qc-persona-icon">ðŸ“Š</span>
                                <span>Delivery Lead</span>
                            </button>
                            <button class="qc-persona-select-option" data-persona="CEO_EXECUTIVE">
                                <span class="qc-persona-icon">ðŸ’¼</span>
                                <span>CEO/Executive</span>
                            </button>
                            <button class="qc-persona-select-option" data-persona="SOFTWARE_ENGINEER">
                                <span class="qc-persona-icon">ðŸ’»</span>
                                <span>Software Engineer</span>
                            </button>
                            <button class="qc-persona-select-option" data-persona="TEST_LEAD">
                                <span class="qc-persona-icon">ðŸ§ª</span>
                                <span>Test Lead</span>
                            </button>
                        </div>
                    </div>
                `;
                
                // Handle persona selection
                confirmDiv.querySelectorAll('.qc-persona-select-option').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const newPersona = this.dataset.persona;
                        correctPersona(newPersona, 'user_selected');
                        confirmDiv.classList.add('qc-fade-out');
                        setTimeout(() => confirmDiv.remove(), 300);

                        // If we have deferred data, re-fetch answer with new persona
                        if (deferredData && deferredData.originalMessage) {
                            sendMessage({
                                messageOverride: deferredData.originalMessage,
                                skipUserMessage: true
                            });
                        }
                    });
                });
            }
            
            function confirmPersona(persona) {
                // Save to localStorage - never show again
                localStorage.setItem('qc_persona_confirmed', 'true');
                localStorage.setItem('qc_persona_choice', persona);
                
                // Show persona badge in header
                if (personaBadge) {
                    personaBadge.style.display = 'flex';
                    if (personaLabel) {
                        personaLabel.textContent = personaNames[persona] || persona;
                    }
                }
                
                // Optionally save to backend for cross-device persistence
                // (Can add API call here if needed)
            }
            
            function correctPersona(newPersona, reason = 'user_selected') {
                if (!newPersona || newPersona === currentPersona) return;
                
                const originalPersona = currentPersona;
                const lastUserMessage = conversationHistory.length > 0 
                    ? conversationHistory[conversationHistory.length - 2]?.content 
                    : null;
                
                // Update UI immediately
                updatePersonaDropdown(newPersona);
                
                // Show persona badge in header
                if (personaBadge) {
                    personaBadge.style.display = 'flex';
                    if (personaLabel) {
                        personaLabel.textContent = personaNames[newPersona] || newPersona;
                    }
                }
                
                // Send correction to backend
                fetch(`${API_BASE}/api/v1/persona/correct`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${accessToken}`
                    },
                    body: JSON.stringify({
                        thread_id: clientThreadId,
                        user_id: memberEmail,
                        corrected_persona: newPersona,
                        original_persona: originalPersona,
                        original_confidence: currentPersonaConfidence,
                        message_context: lastUserMessage,
                        correction_reason: reason
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        currentPersona = newPersona;
                        showStatus(`Persona updated to ${personaNames[newPersona]}. Your next responses will be tailored accordingly.`, 'info');
                        setTimeout(() => showStatus('', ''), 3000);
                        
                        if (typeof gtag !== 'undefined') {
                            gtag('event', 'persona_corrected', {
                                'from': originalPersona,
                                'to': newPersona,
                                'reason': reason
                            });
                        }
                    }
                })
                .catch(error => {
                    console.error('Failed to update persona:', error);
                });
            }

            function addMessage(content, role, sources, isFeedbackMessage = false) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'qc-message qc-message-' + role;

                const bubble = document.createElement('div');
                bubble.className = 'qc-message-bubble';

                if (role === 'user') {
                    bubble.textContent = content;
                } else {
                    bubble.innerHTML = formatMessage(content);
                }

                if (isFeedbackMessage) {
                    messageDiv.classList.add('qc-message-feedback');
                    const feedbackLabel = document.createElement('div');
                    feedbackLabel.className = 'qc-feedback-message-label';
                    feedbackLabel.textContent = 'Feedback sent to Anne-Marie';
                    messageDiv.appendChild(feedbackLabel);
                }

                messageDiv.appendChild(bubble);

                // Sources attribution (only for assistant messages)
                if (role === 'assistant') {
                    const sourcesDiv = document.createElement('div');
                    sourcesDiv.className = 'qc-sources-container';
                    
                    // Check if we have high-quality handbook sources (similarity > 0.5)
                    const handbookSources = sources && sources.filter(s => s.similarity >= 0.5);
                    const hasHandbookSources = handbookSources && handbookSources.length > 0;
                    
                    if (hasHandbookSources) {
                        // Get unique chapter/section names
                        const chapterNames = [...new Set(
                            handbookSources.map(s => s.section || s.label || s.chapter || 'Handbook')
                        )].slice(0, 3); // Max 3 chapters
                        
                        sourcesDiv.innerHTML = `
                            <div class="qc-sources-badge qc-sources-handbook">
                                <span class="qc-sources-icon">ðŸ“š</span>
                                <span class="qc-sources-label">From the Handbook:</span>
                                <span class="qc-sources-chapters">${chapterNames.join(', ')}</span>
                            </div>
                        `;
                    } else {
                        // No high-quality handbook sources - indicate general knowledge
                        sourcesDiv.innerHTML = `
                            <div class="qc-sources-badge qc-sources-general">
                                <span class="qc-sources-icon">ðŸ’¡</span>
                                <span class="qc-sources-label">General coaching guidance</span>
                            </div>
                        `;
                    }
                    
                    messageDiv.appendChild(sourcesDiv);
                }

                if (role === 'assistant') {
                    lastAssistantMessage = messageDiv;
                    
                    // Add Action Bar (Copy, Thumbs Up, Thumbs Down)
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'qc-message-actions';
                    
                    // Copy Button
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'qc-action-btn';
                    copyBtn.title = 'Copy to clipboard';
                    copyBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                    copyBtn.onclick = () => {
                        navigator.clipboard.writeText(content);
                        copyBtn.classList.add('is-active');
                        setTimeout(() => copyBtn.classList.remove('is-active'), 1000);
                    };
                    
                    // Thumbs Up
                    const upBtn = document.createElement('button');
                    upBtn.className = 'qc-action-btn';
                    upBtn.title = 'Helpful';
                    upBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path></svg>';
                    upBtn.onclick = () => handleFeedback(messageDiv, 'positive', upBtn);

                    // Thumbs Down
                    const downBtn = document.createElement('button');
                    downBtn.className = 'qc-action-btn';
                    downBtn.title = 'Not helpful';
                    downBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path></svg>';
                    downBtn.onclick = () => handleFeedback(messageDiv, 'negative', downBtn);

                    actionsDiv.appendChild(copyBtn);
                    actionsDiv.appendChild(upBtn);
                    actionsDiv.appendChild(downBtn);
                    messageDiv.appendChild(actionsDiv);
                }

                messages.appendChild(messageDiv);
                messages.scrollTop = messages.scrollHeight;
            }

            function handleFeedback(messageDiv, rating, btn) {
                // Remove existing feedback forms in this message if any
                const existingForm = messageDiv.querySelector('.qc-inline-feedback');
                if (existingForm) existingForm.remove();

                // Highlight button
                const buttons = messageDiv.querySelectorAll('.qc-action-btn');
                buttons.forEach(b => b.classList.remove('is-active'));
                btn.classList.add('is-active');

                // Create inline form
                const form = document.createElement('div');
                form.className = 'qc-inline-feedback';
                
                const textarea = document.createElement('textarea');
                textarea.placeholder = rating === 'positive' ? 'What was helpful? (Optional)' : 'How can we improve this? (Optional)';
                
                const actions = document.createElement('div');
                actions.className = 'qc-inline-actions';
                
                const cancelBtn = document.createElement('button');
                cancelBtn.className = 'qc-btn-xs qc-btn-ghost';
                cancelBtn.textContent = 'Cancel';
                cancelBtn.onclick = () => {
                    form.remove();
                    btn.classList.remove('is-active');
                };

                const submitBtn = document.createElement('button');
                submitBtn.className = 'qc-btn-xs qc-btn-primary';
                submitBtn.textContent = 'Send Feedback';
                submitBtn.onclick = () => {
                    const comment = textarea.value.trim();
                    submitBtn.disabled = true;
                    submitBtn.textContent = 'Sending...';
                    
                    submitFeedback(rating, comment).then(() => {
                        form.innerHTML = '<div style="color: var(--qc-accent); font-size: 13px; font-weight: 500;">Thanks for your feedback!</div>';
                        setTimeout(() => {
                            form.remove();
                        }, 2000);
                    }).catch(() => {
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Send Feedback';
                    });
                };

                actions.appendChild(cancelBtn);
                actions.appendChild(submitBtn);
                form.appendChild(textarea);
                form.appendChild(actions);
                
                messageDiv.appendChild(form);
                textarea.focus();
            }

            function submitFeedback(rating, comment) {
                return sendMessage({
                    messageOverride: comment || rating, // Send rating if comment is empty
                    isFeedbackOverride: true
                });
            }
        });
        </script>
    </div>
{{else}}
    <div class="qc-locked-message">
        The Quality Coach Researcher is available to members only. Sign in to request beta access.
    </div>
{{/if}}
